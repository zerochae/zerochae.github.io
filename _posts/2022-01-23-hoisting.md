---
title: JavaScript &#35;4
date: 2022-01-23 09:00
description: Hoisting
category: JavaScript
icon: js
tags: [JavaScript]
---

# Hoisting

**호이스팅**은 JavaScript 코드를 인터프리터가 로드할 때, 변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 끌어 올리는 것을 말한다. 이는 오로지 변수에만 해당되는 것은 아니고 함수도 가능하며, JavaScript에서 함수의 호출을 첫 줄에서 하고 마지막 줄에 함수를 정희해도 문제없이 작동되도록 하는 유용한 특성이다.

JavaScript는 함수의 코드를 실행하기 전에 함수 선언에 대한 메모리부터 할당한다. 덕분에 함수를 호출하는 코드를 함수 선언보다 앞서 배치할 수 있다.

## How to Execution Code in JavaScript

먼저 자바스크립트가 코드를 어떻게 실행하는지 이해할 필요가 있다. 자바스크립트 엔진은 소스코드를 평가하고 실행하는 2가지의 과정으로 진행된다. 소스코드의 평가 과정에서는 선언문으로 작성된 변수와 함수 등을 실행하여 변수와 함수 식별자로 키로 하여 [실행 컨텍스트](https://zerochae.github.io/javascript/2022/01/22/ExecutionContext/)가 관리하는 환경에 등록한다. 평가 과정이 끝났다면 소스코드가 순차적으로 실행된다. 소스코드가 실행된다는 것은 런타임이 시작된다는 의미이다. 이 때 어떠한 변수나 함수를 만났다면 실행 컨텍스트가 관리하는 환경에서 검색하여 참조하게 된다.

자바스크립트는 소소코드를 평가하고 실행하기 대문에 런타임 이전에 선언한 변수와 함수를 실행 컨텍스트가 관리하는 환경에 등록하게 된다. 이에 따라 호이스팅이 발생하게 되는 것이다. 평가 과정에서 key-value 상으로 변수와 함수를 등록할 때 해당 변수와 함수 식별자를 key로 하고 value는 `undefined`를 등록하게 된다.

## Function Hoisting

```js
function myChamp(name) {
  console.log("제 챔피언은" + name + "입니다");
}

myChamp("나르"); // "제 챔피언은 나르입니다."
```

위의 예제는 일반적으로 코드를 작성하는 순서이다.

```js
myChamp("티모"); // "제 챔피언은 티모입니다."

function myChamp(name) {
  console.log("제 챔피언은" + name + "입니다");
}
```

함수를 선언하기 전에 먼저 호출부터 했지만 문제 없이 작동한다. 이것이 JavaScript에서 실행 맥락이 동작하는 방식인 호이스팅이다.

## Variable Hoisting

JavaScript는 초기화를 제외한 선언만 호이스팅한다. 변수를 먼저 사용하고 그 후에 선언 및 초기화가 나타나면, 사용하는 시점의 변수는 기본 초기화 상태(`var` 선언 시 `undefined`, 그 외에는 초기화하지 않음)이다.

### Var

```js
console.log(gnar); // 호이스팅한 var 선언으로 인해 undefined 출력
var gnar; // 선언
gnar = "나르"; // 초기화
```

`var`를 사용했기 때문에 기본 초기화 상태인 `undefined`가 출력된다.

```js
console.log(gnar); // ReferenceError
gnar = "나르"; // 초기화
```

위 예제에서는 선언 없이 초기화만 존재한다. 따라서 호이스팅도 없고, 변수를 읽으려는 시도에서 `ReferenceError` 예외가 발생한다. **선언없이 값만 초기화하면 변수가 호이스팅되지 않는다!**

```js
name = "나르"; // name 초기화
age = "10000살"; // age 초기화

console.log(name + ": " + age); // '나르: 10000살'
```

위 코드는 문제 없이 작동한다. 호이스팅이 되지 않았지만 변수가 사용되기 전에 초기화되었기 때문이다.

### let & const

`let`과 `const`로 선언한 변수도 호이스팅 대상이지만, `var`와 달리 호이스팅 시 `undefined`로 변수를 초기화하지 않는다. 따라서 변수의 초기화를 수행하기 전에 읽는 코드가 먼저 나타나면 예외가 발생한다.

```js
console.log(gnar); // ReferenceError
let gnar = "나르"; // 초기화
```

`var`와는 다르게 `undefined`를 출력하지 않고, 참조할 수 없다는 에러가 발생한다.

```js
console.log(gnar); // ReferenceError
let gnar; // 선언
console.log(gnar); // undefined
gnar = "나르"; // 초기화
console.log(gnar); // "나르"
```

위의 코드에서 `var`와 `let` & `const`의 차이점을 확실하게 알 수 있다.

`var`는 선언과 초기화가 동시에 진행된다. 즉 `gnar`라는 변수를 선언했다면 동시에 `undefined`로 초기화 되는 것이다. 하지만 `let`과 `const`는 선언 이후에 초기화 과정이 이루어진다. `var`는 `undefined`로 초기화되었기 대문에 참조가 가능하다. 하지만 `let`과 `const`는 선언 이후에 값을 할당하기 전까지 초기화가 이루어지지 않기 때문에 참조가 불가능하다.

이처럼 선언하고 초기화 전까지를 **일시적 사각지대(TDZ)**라고 한다.

`let`과 `const`로 선언한 변수가 호이스팅이 발생하지 않는 것은 아니다. 마치 호이스팅이 발생하지 않는 것처럼 보이는 것이다. 단지 선언과 초기화 과정이 나눠지기 때문에 해당 선언문이 만나기 전까지 초기화가 되어있지 않아 참조가 불가능한 것이다. 하지만 이러한 제약으로 인해 개발자들의 실수를 줄일 수 있을 것이다.

```js
let gnar; // 전역 변수
{
  console.log(gnar); // ReferenceError
  let gnar = "나르"; // 지역 변수
}
```

만약 `let`과 `const`로 선언한 변수가 호이스팅이 발생하지 않는다면 `gnar`는 `undefined` 라고 출력될 것이다. 하지만 지역 변수가 호이스팅이 발생한 것이다. 즉 블록 안에서 지역 변수 `gnar`가 선언되었고 초기화는 진행되지 않은 것이다. 따라서 `gnar`를 출력하려고 할 때 스코프 체인으로 변수를 탐색하고 블록 안에서 선언한 `gnar`를 찾아 출력하였다. 하지만 지역 변수 `gnar`는 초기화 이전 단계이기 때문에 참조가 불가능하다는 에러가 발생하였다.

## 마무리

ES6 이후로 **실제 현업에서는 var 키워드는 절대로 쓰이지 않으며 99% 이상의 경우 모든 함수를 const와 arrow syntax로 선언하기 때문에 최근 들어서는 사실상 크게 신경쓰지 않는 부분이 되었다고 한다.**

자바스크립트 개발자 면접에서 아직도 호이스팅을 물어 보는 이유가 뭐냐는 [Dan Abramov의 트윗](https://twitter.com/dan_abramov/status/1362530955420987396)이 화제가 되었는데, 호이스팅이 어떤 문제를 풀려고 했으며 그 문제를 모던 JS에서는 어떻게 다루는지 대해 알고 있으면 나쁘지 않다고 보는 견해도 있다.
