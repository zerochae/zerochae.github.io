---
title: CS &#35;1
description: 0.1 + 0.2 === 0.3은 true일까 false일까
date: 2022-03-29 09:00
category: CS
tags: [CS]
---

true를 예상하지만 위의 답은 false이다.

```js
const output = 0.1 + 0.2 === 0.3;
console.log(output); // false
```

0.1 + 0.2를 출력해보면 전혀 기대하지 못한 결과를 출력한다.

```js
const output = 0.1 + 0.2;
console.log(output); // 0.30000000000000004
```

. 뒤에 붙은 0000....4 는 어디서 나온걸까?

## 컴퓨터의 실수(Real Number)

우리는 일상에서 10진수(Decimal)를 사용하지만, 컴퓨터는 10진수로 입력된 값을 2진수(Binary)로 처리한다.

따라서

- Binary $0.1$은 Decimal $0.5$
- Binary $0.01$은 Decimal $0.25$
- Binary $0.001$은 Decimal $0.125$
- Binary $0.0001$은 Decimal $0.0625$

라는 결과가 나온다.

그렇다면 $0.1_{(10)}$은 2진수로 얼마가 될까?

소수점 이하 4자리 범위 내에서 나타낼 수 있는 수는 다음과 같다.

$$
0.0000_{(2)} 에서 0.1111_{(2)} 까지
$$

위의 범위는 위 계산 결과의 조합으로 밖에 표시 할 수 없고, 이는 $0$과 $0.0625$ 사이의 값은 표현할 수 없다는 걸 의미한다.

결론적으로 $0.0625$ 다음은 $0.125$ 이므로 $0.1$을 만드는것은 불가능하다.

## 컴퓨터가 실수를 저장 하는 방법

컴퓨터가 $0.1_{(10)}$을 정확하게 처리하지 못하는 이유는 2진수로 나타냈을때 $0.00011001100 ...$ 처럼 순환소수가 되어버리기 때문이다.

하지만 컴퓨터가 무한한 숫자를 저장할 수 없기때문에 일정한 Bit로 끊어서 반올림해 저장한다. (JavaScript는 64bit)

이런 이유 때문에 앞서 계산한 `0.1 + 0.2`가 위 같은 결과를 보인 것이다.

## 정확한 계산 방법

```js
const num1 = 0.1;
const num2 = 0.2;
const n = 1; // 소숫점 아래 최대 유효 숫자

const output = ((num1 * 10 ** n) + (num2 * 10 ** n) / 10 ** n;
console.log(output) // 0.3
```

